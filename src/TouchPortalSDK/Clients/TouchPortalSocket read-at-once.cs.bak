using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using TouchPortalSDK.Interfaces;

namespace TouchPortalSDK.Clients
{
    public class TouchPortalSocket : ITouchPortalSocket
    {
        public bool IsConnected { get => _socket?.Connected ?? false; }

        private readonly TouchPortalOptions _options;
        private readonly IMessageHandler _messageHandler;
        private readonly ILogger<TouchPortalSocket> _logger;
        private readonly Socket _socket;
        private readonly Thread _listenerThread;
        private readonly CancellationTokenSource _cts;
        private readonly CancellationToken _cancellationToken;

        private StreamWriter _streamWriter;

        public TouchPortalSocket(TouchPortalOptions options,
                                 IMessageHandler messageHandler,
                                 ILoggerFactory loggerFactory = null)
        {
            _options = options;
            _messageHandler = messageHandler;
            _logger = loggerFactory?.CreateLogger<TouchPortalSocket>();

            _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            _cts = new CancellationTokenSource();
            _cancellationToken = _cts.Token;
            _listenerThread = new Thread(ListenerThreadSync) { IsBackground = false };
        }

        /// <inheritdoc cref="ITouchPortalSocket" />
        bool ITouchPortalSocket.Connect()
        {
            try
            {
                //Connect
                var ipAddress = IPAddress.Parse(_options.IpAddress);
                var socketAddress = new IPEndPoint(ipAddress, _options.Port);

                _socket.Connect(socketAddress);

                _logger?.LogInformation("TouchPortal connected.");

                //Setup streams:
                //The encoder needs to be without a BOM / Utf8 Identifier:
                _streamWriter = new StreamWriter(new NetworkStream(_socket), new UTF8Encoding(false)) {AutoFlush = true, };

                _logger?.LogInformation("Streams created.");

                return _socket.Connected;
            }
            catch (IOException exception)
            {
                //Ex. System.IO.IOException: The operation is not allowed on non-connected sockets
                _logger?.LogWarning(exception, "Socket was not open, stream creation failed.");
                return false;
            }
            //Warning: SocketErrors in .Net might depend on OS and Runtime: https://blog.jetbrains.com/dotnet/2020/04/27/socket-error-codes-depend-runtime-operating-system/
            catch (SocketException exception)
                when (exception.SocketErrorCode == SocketError.ConnectionRefused)
            {
                //Could not connect to Touch Portal, ex. Touch Portal is not running.
                //Ex. No connection could be made because the target machine actively refused it. 127.0.0.1:12136
                _logger?.LogWarning(exception, "Could not connect to Touch Portal, connection refused. Touch Portal might not be running.");

                return false;
            }
            catch (SocketException exception)
            {
                _logger?.LogWarning(exception, $"Could not connect to Touch Portal with error code: '{exception.SocketErrorCode}'.");

                return false;
            }
        }

        /// <inheritdoc cref="ITouchPortalSocket" />
        bool ITouchPortalSocket.Listen()
        {
            //_logger?.LogInformation("Callback method set.");

            //Create listener thread:
            _logger?.LogInformation("Starting Listener thread...");
            _listenerThread.Start();

            return _listenerThread.IsAlive;
        }

        /// <inheritdoc cref="ITouchPortalSocket" />
        /*async Task<bool>*/ bool ITouchPortalSocket.SendMessage(string jsonMessage)
        {
            if (!_socket.Connected)
            {
                _logger?.LogWarning("Socket not connected to Touch Portal.");
                return false;
            }

            if (_streamWriter is null)
            {
                _logger?.LogWarning("StreamWriter was not initialized. Message cannot be sent.");
                return false;
            }

            try
            {
                // Task.Run(delegate { _streamWriter.WriteLineAsync(jsonMessage); } );
                _streamWriter.WriteLineAsync(jsonMessage).ConfigureAwait(false);
                _logger?.LogDebug("Message queued.");
                return true;
            }
            catch (Exception exception)
            {
                _logger?.LogWarning(exception, "SendMessage exception in _streamWriter.WriteLineAsync()");
                return false;
            }
        }

        /// <inheritdoc cref="ITouchPortalSocket" />
        void ITouchPortalSocket.CloseSocket()
        {
            _cts.Cancel();
            if (_socket.Connected && _listenerThread.IsAlive && !_listenerThread.Join(2000)) {
              _logger.LogWarning("Network stream is hung up, interrupting the listener thread.");
              _listenerThread.Interrupt();
            }
            _streamWriter?.Close();
            _socket.Shutdown(SocketShutdown.Both);
            _socket.Close();
        }

        private void ListenerThreadSync()
        {
            _logger?.LogInformation("Listener thread created and started.");

            const int buffLen = 1024 * 8;
            byte[] rcvBuffer = new byte[buffLen];
            byte[] empty = new byte[1];  // for ping
            var encoding = new UTF8Encoding(false);
            //var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            int buffPos = 0;
            int rcvLen;
            _socket.Blocking = false;
            //_socket.ReceiveTimeout = 1000;
            try
            {
                while (!_cancellationToken.IsCancellationRequested && _socket.Connected)
                {
                    try {
                        //while (!_cancellationToken.IsCancellationRequested && _socket.Available > 0)
                        while (!_cancellationToken.IsCancellationRequested && (rcvLen = _socket.Receive(rcvBuffer, buffPos, buffLen - buffPos, SocketFlags.None)) > 0)
                        {
                            //if (_socket.Receive(rcvBuffer, buffPos, 1, SocketFlags.None) < 1)  // uncomment is using _socket.Available
                            //    continue;
                            int nextIdx = 0;
                            int lenRemaining = buffPos + rcvLen;
                            while ((Array.IndexOf(rcvBuffer, (byte)10, nextIdx, lenRemaining) is int nlIdx) && nlIdx > -1) {
                                if (nlIdx == 0) {
                                    ++nextIdx;
                                    continue;
                                }
                                ++nlIdx;  // include the newline
                                var lineLen = nlIdx - nextIdx;
                                var line = encoding.GetString(rcvBuffer, nextIdx, lineLen);
                                nextIdx = nlIdx;
                                lenRemaining -= lineLen;
                                _logger?.LogDebug(line);
                                _messageHandler.OnMessage(line);
                            }
                            if (nextIdx == 0) {
                                buffPos += rcvLen;
                            }
                            else if (lenRemaining > 0) {
                                buffPos = lenRemaining;
                                Buffer.BlockCopy(rcvBuffer, nextIdx, rcvBuffer, 0, buffPos);
                            }
                            else {
                                buffPos = 0;
                            }
                            if (buffPos >= buffLen) {
                                _logger?.LogError("Receive buffer overflow!");
                                buffPos = 0;
                            }
                        }
                    }
                    // this try/catch is not needed if using _socket.Available
                    catch (SocketException e) {
                      if (e.SocketErrorCode == SocketError.TimedOut)     // for blocking socket
                        continue;
                      if (e.SocketErrorCode != SocketError.WouldBlock)   // for non-blocking, means no data to rcv
                        throw e;
                    }
                    // for blocking socket, this wait can be removed and sleep time is controlled with _socket.ReceiveTimeout
                    _cancellationToken.WaitHandle.WaitOne(20);

                    // if using _socket.Available then need to ping the socket occasionally to check health. This will throw SocketException if the host has gone away.
                    //if (stopwatch.ElapsedMilliseconds > 5000) {
                    //    stopwatch.Restart();
                    //    _socket.Send(empty, 0, 0);
                    //}
                }
                if (!_socket.Connected && !_cancellationToken.IsCancellationRequested) {
                  _messageHandler.Close("Connection Terminated, Touch Portal quit without a goodbye.", null);
                }
            }
            catch (IOException exception)
            {
                _messageHandler.Close("Connection Terminated (most likely Touch Portal quit without a goodbye).", exception);
            }
            catch (SocketException exception)
            {
                _messageHandler.Close("Connection Terminated (most likely Touch Portal quit without a goodbye).", exception);
            }
            catch (ThreadInterruptedException exception)
            {
                if (!_cancellationToken.IsCancellationRequested)
                  _messageHandler.Close("Listener thread interrupted externally.", exception);
                else
                  _logger?.LogError(exception, "The Listener Thread was interrupted, with cancellation requested: {0}.", _cancellationToken.IsCancellationRequested);
            }
            catch (Exception exception)
            {
                _messageHandler.Close("Unknown exception in listener thread, quitting now.", exception);
            }

            _logger?.LogInformation("Listener thread exited.");
        }
    }
}
